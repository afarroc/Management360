{% load static %}
<!-- Panel flotante de chat para incluir en base.html -->
<!-- Botón flotante para restaurar chat -->
<button id="chat-restore-btn" class="btn btn-primary rounded-circle d-flex align-items-center justify-content-center" style="display:none;">
    <i class="bi bi-chat-dots"></i>
</button>

<div id="chat-panel" class="docked card">
    <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center chat-header">
        <span>
            <i class="bi bi-chat-dots me-2"></i>Chat
            <select id="chat-room-selector" class="form-select form-select-sm d-inline-block w-auto ms-2">
                <option value="" disabled selected>Selecciona una sala...</option>
            </select>
        </span>
        <div class="d-flex gap-1">
            <button id="go-chat-main-btn" class="btn btn-light btn-sm" title="Ir al chat principal">
                <i class="bi bi-box-arrow-up-right"></i>
            </button>
            <button id="toggle-dock-btn" class="btn btn-light btn-sm" title="Acoplar/desacoplar">
                <i class="bi bi-layout-sidebar-inset"></i>
            </button>
            <button id="toggle-chat-panel" class="btn btn-link text-white p-0" style="font-size:1.5rem; line-height:1;">
                &#8211;
            </button>
        </div>
    </div>

    <div id="chat-panel-body" class="chat-panel-body">
        <div id="chat-log">
            <div class="d-flex mb-2 justify-content-end">
                <div class="message-bubble outgoing">
                    <div class="small fw-bold mb-1">You</div>
                    <div class="message-content">¡Bienvenido al chat!</div>
                    <div class="message-time small mt-1 text-muted">Ahora</div>
                </div>
            </div>
            <div id="typing-indicator" class="typing-indicator">
                <span></span><span></span><span></span> escribiendo...
            </div>
        </div>
    </div>

    <div class="chat-info-containers d-flex flex-column">
        <div class="input-group">
            <input id="chat-message-input" type="text" class="form-control" placeholder="Escribe tu mensaje..." autocomplete="off">
            <button id="chat-message-submit" class="btn btn-primary">
                <i class="bi bi-send"></i>
            </button>
        </div>
    </div>
</div>
<script>
    function setPanelMode(mode) {
        const panel = document.getElementById('chat-panel');
        panel.classList.remove('fullscreen', 'docked');
        panel.classList.add(mode);
    }
    function isMobile() {
        return window.innerWidth <= 600;
    }
    document.addEventListener('DOMContentLoaded', async function() {
    const currentUserId = "{{ user_id|default:'' }}";
        const panel = document.getElementById('chat-panel');
        const toggleDockBtn = document.getElementById('toggle-dock-btn');
        const toggleChatPanelBtn = document.getElementById('toggle-chat-panel');
        const restoreBtn = document.getElementById('chat-restore-btn');
        const goChatMainBtn = document.getElementById('go-chat-main-btn');
    const chatLog = document.getElementById('chat-log');
    const chatInput = document.getElementById('chat-message-input');
    const chatSubmit = document.getElementById('chat-message-submit');
    const roomSelector = document.getElementById('chat-room-selector');

        // Detecta si está en la página principal de chat
        function isChatMainPage() {
            return window.location.pathname.startsWith('/chat/room');
        }

        // Estado inicial del panel flotante
        let chatPanelState = localStorage.getItem('chatPanelState') || 'minimized';
        function applyPanelState(state) {
            if (isChatMainPage()) {
                setPanelMode('fullscreen');
                panel.classList.remove('hidden');
                restoreBtn.style.display = 'none';
            } else {
                setPanelMode('docked');
                if (state === 'minimized') {
                    panel.classList.add('hidden');
                    restoreBtn.style.display = 'flex';
                    restoreBtn.style.opacity = '1';
                } else {
                    panel.classList.remove('hidden');
                    restoreBtn.style.display = 'none';
                    restoreBtn.style.opacity = '0';
                }
            }
        }
        applyPanelState(chatPanelState);
        // Siempre mostrar funcionalidades completas en modo docked
        if (isMobile() && !isChatMainPage()) {
            setPanelMode('docked');
            // En móvil, mostrar siempre el contenido completo en docked
            const panelBody = document.querySelector('.chat-panel-body');
            const infoContainers = document.querySelector('.chat-info-containers');
            if (panelBody) panelBody.style.display = 'flex';
            if (infoContainers) infoContainers.style.display = 'flex';
        }
        toggleDockBtn.addEventListener('click', function() {
            if (panel.classList.contains('docked')) {
                setPanelMode('fullscreen');
                localStorage.setItem('chatPanelState', 'maximized');
            } else {
                setPanelMode('docked');
                localStorage.setItem('chatPanelState', 'docked');
            }
        });
        toggleChatPanelBtn.addEventListener('click', function() {
            panel.classList.add('hidden');
            restoreBtn.style.display = 'flex';
            restoreBtn.style.opacity = '1';
            localStorage.setItem('chatPanelState', 'minimized');
        });
        restoreBtn.addEventListener('click', function() {
            panel.classList.remove('hidden');
            restoreBtn.style.display = 'none';
            restoreBtn.style.opacity = '0';
            // Si está en la página principal de chat, restaurar pantalla completa
            if (isChatMainPage()) {
                setPanelMode('fullscreen');
                localStorage.setItem('chatPanelState', 'maximized');
            } else {
                setPanelMode('docked');
                localStorage.setItem('chatPanelState', 'docked');
            }

            // Reset unread count when panel is restored
            if (lastRoomId) {
                setTimeout(() => resetUnreadCount(lastRoomId), 500);
            }
        });
        window.addEventListener('resize', function() {
            if (isMobile() && !isChatMainPage()) {
                setPanelMode('docked');
                document.querySelector('.chat-panel-body').style.display = 'flex';
                document.querySelector('.chat-info-containers').style.display = 'flex';
            }
        });
        goChatMainBtn.addEventListener('click', function() {
            const currentRoom = roomSelector.value;
            if (currentRoom) {
                window.location.href = `/chat/room/${currentRoom}/`;
            } else {
                window.location.href = '/chat/room';
            }
        });

        // --- Obtener sala por defecto según historial de último acceso ---
        async function getLastRoom() {
            try {
                const response = await fetch('/chat/api/chat/last-room/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    return data.room_name || 'global';
                }
            } catch (e) {
                console.error('Error fetching last room:', e);
            }
            return 'global';
        }

        let chatSocket = null;
        let reconnectTimeout = null;
        let intentionalClose = false;
        let typingTimeout = null;
        let isTyping = false;
        let isPageVisible = true;
        let unreadMessageCount = 0;
        let isWidgetActive = false;
        let widgetVisibilityObserver = null;
        let readReceiptTimeout = null;
    // let lastRoomId = null; // Eliminada declaración duplicada

        async function loadRoomsAndSelectLast() {
            let lastRoom = await getLastRoom();
            try {
                const response = await fetch('/chat/api/chat/room-list/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    roomSelector.innerHTML = '<option value="" disabled>Selecciona una sala...</option>';
                    data.rooms.forEach(room => {
                        const option = document.createElement('option');
                        option.value = room.id;
                        option.textContent = room.name;
                        roomSelector.appendChild(option);
                    });
                    // Check localStorage first for panel-specific last room
                    let selectedRoom = localStorage.getItem('chatPanelLastRoom') || lastRoom;

                    // Selecciona la sala por defecto si existe
                    if (selectedRoom && data.rooms.some(room => room.id == selectedRoom)) {
                        roomSelector.value = selectedRoom;
                        lastRoomId = selectedRoom;
                        console.log('Panel: Selected stored/last room:', selectedRoom);
                    } else if (lastRoom && data.rooms.some(room => room.id == lastRoom)) {
                        roomSelector.value = lastRoom;
                        lastRoomId = lastRoom;
                        localStorage.setItem('chatPanelLastRoom', lastRoom);
                        console.log('Panel: Selected API last room:', lastRoom);
                    } else if (data.rooms.length > 0) {
                        // Fallback to first available room
                        const firstRoom = data.rooms[0].id;
                        roomSelector.value = firstRoom;
                        lastRoomId = firstRoom;
                        localStorage.setItem('chatPanelLastRoom', firstRoom);
                        console.log('Panel: Selected first available room:', firstRoom);
                    }
                } else {
                    console.error('Panel: Failed to load rooms:', response.status);
                }
            } catch (e) {
                console.error('Panel: Error loading rooms:', e);
            }
        }

        await loadRoomsAndSelectLast();

        async function loadHistory(roomId) {
            chatLog.innerHTML = '';
            try {
                const response = await fetch(`/chat/api/chat/room-history/${roomId}/`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'same-origin'
                });
                if (response.ok) {
                    const data = await response.json();
                    if (Array.isArray(data.history)) {
                        data.history.forEach(msg => {
                            const isCurrentUser = msg.user_id == currentUserId;
                            const msgHtml = `<div class="d-flex mb-2 justify-content-${isCurrentUser ? 'end' : 'start'}">
                                <div class="message-bubble px-3 py-2 ${isCurrentUser ? 'outgoing text-white text-end' : 'incoming text-dark text-start'}" style="max-width: 75%; border-radius: 1.2em; background:${isCurrentUser ? '#007bff' : '#f8f9fa'};">
                                    <div class="small fw-bold mb-1">${msg.display_name || 'Usuario'}</div>
                                    <div class="message-content">${msg.content}</div>
                                    <div class="message-time small mt-1 text-muted">${msg.timestamp ? msg.timestamp.substring(11,19) : ''}</div>
                                </div>
                            </div>`;
                            chatLog.insertAdjacentHTML('beforeend', msgHtml);
                        });
                        chatLog.scrollTop = chatLog.scrollHeight;
                    }
                } else {
                    console.error('Panel: Failed to load history:', response.status);
                }
            } catch (e) {
                console.error('Panel: Error loading history:', e);
            }
        }

        function showTypingIndicator(userId, displayName) {
            const typingIndicator = document.getElementById('typing-indicator');
            if (!typingIndicator) return;
            typingIndicator.innerHTML = `<span></span><span></span><span></span> ${displayName} is typing...`;
            typingIndicator.style.display = 'block';
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        }

        function handleHistoryCleared() {
            // Clear all messages from the chat log but keep the typing indicator
            const chatLog = document.getElementById('chat-log');
            const typingIndicator = document.getElementById('typing-indicator');
            chatLog.innerHTML = '';
            if (typingIndicator) {
                chatLog.appendChild(typingIndicator);
            }
            // Show a system message indicating history was cleared
            const systemMessage = document.createElement('div');
            systemMessage.className = 'text-center p-2';
            systemMessage.innerHTML = '<small class="text-muted">Chat history has been cleared</small>';
            chatLog.appendChild(systemMessage);
        }

        function resetUnreadCount(roomId) {
            if (!roomId) return;

            fetch('/chat/api/chat/reset-unread/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                },
                body: JSON.stringify({
                    'room_id': roomId
                }),
                credentials: 'same-origin'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`Panel: Marked ${data.marked_read} messages as read for room ${roomId}`);
                    // Update the notification count in the header
                    if (window.updateNotificationCount) {
                        window.updateNotificationCount();
                    }
                    // Also trigger notification system refresh
                    if (window.NotificationManager && window.NotificationManager.forceRefresh) {
                        window.NotificationManager.forceRefresh();
                    }
                    // Dispatch custom event for other components
                    document.dispatchEvent(new CustomEvent('messagesMarkedAsRead', {
                        detail: { roomId: roomId, count: data.marked_read }
                    }));
                    // Update notification count immediately
                    if (window.updateNotificationFromWidget) {
                        window.updateNotificationFromWidget();
                    }
                    // Reset local unread counter
                    unreadMessageCount = 0;
                }
            })
            .catch(error => console.error('Panel: Error resetting unread count:', error));
        }

        function setupWidgetVisibilityObserver() {
            const panel = document.getElementById('chat-panel');
            if (!panel) return;

            // Disconnect existing observer
            if (widgetVisibilityObserver) {
                widgetVisibilityObserver.disconnect();
            }

            // Create new observer
            widgetVisibilityObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const wasActive = isWidgetActive;
                    isWidgetActive = entry.isIntersecting && isPageVisible && !panel.classList.contains('hidden');

                    console.log('Panel: Widget visibility changed:', {
                        isIntersecting: entry.isIntersecting,
                        isPageVisible,
                        isHidden: panel.classList.contains('hidden'),
                        isWidgetActive
                    });

                    // If widget became active and there are unread messages, mark them as read
                    if (isWidgetActive && !wasActive && unreadMessageCount > 0 && lastRoomId) {
                        console.log('Panel: Widget became visible, marking messages as read');
                        clearTimeout(readReceiptTimeout);
                        readReceiptTimeout = setTimeout(() => {
                            resetUnreadCount(lastRoomId);
                        }, 1000); // Wait 1 second to ensure user is actually reading
                    }
                });
            }, {
                threshold: 0.1, // Consider visible if at least 10% is visible
                rootMargin: '0px'
            });

            widgetVisibilityObserver.observe(panel);
        }

        function updateWidgetActiveState() {
            setupWidgetVisibilityObserver();
        }

        // Handle page visibility changes for smart read receipts
        document.addEventListener('visibilitychange', function() {
            isPageVisible = !document.hidden;
            console.log('Panel: Page visibility changed:', isPageVisible ? 'visible' : 'hidden');
            updateWidgetActiveState();
        });

        // Handle window focus/blur for better activity detection
        window.addEventListener('focus', function() {
            console.log('Panel: Window focused');
            isPageVisible = true;
            updateWidgetActiveState();

            // Mark messages as read when window gains focus and widget is visible
            if (isWidgetActive && unreadMessageCount > 0 && lastRoomId) {
                clearTimeout(readReceiptTimeout);
                readReceiptTimeout = setTimeout(() => {
                    resetUnreadCount(lastRoomId);
                }, 200); // Reduced to 200ms for faster response
            }
        });

        window.addEventListener('blur', function() {
            console.log('Panel: Window blurred');
            isPageVisible = false;
            updateWidgetActiveState();
        });

        // Handle widget state changes (minimize/maximize)
        toggleChatPanelBtn.addEventListener('click', function() {
            setTimeout(updateWidgetActiveState, 100);
        });

        toggleDockBtn.addEventListener('click', function() {
            setTimeout(updateWidgetActiveState, 100);
        });

        restoreBtn.addEventListener('click', function() {
            setTimeout(updateWidgetActiveState, 100);
        });

        // Enhanced mobile touch interactions
        function initializeMobileInteractions() {
            const isMobile = window.innerWidth <= 768;

            if (isMobile) {
                // Add swipe gesture for chat panel
                let startY = 0;
                let startX = 0;
                let isSwiping = false;

                const chatPanel = document.getElementById('chat-panel');
                const swipeIndicator = document.createElement('div');
                swipeIndicator.className = 'swipe-indicator';
                swipeIndicator.textContent = 'Swipe to close';
                document.body.appendChild(swipeIndicator);

                // Touch start
                chatPanel.addEventListener('touchstart', function(e) {
                    if (chatPanel.classList.contains('fullscreen')) {
                        startY = e.touches[0].clientY;
                        startX = e.touches[0].clientX;
                        isSwiping = true;
                    }
                }, { passive: true });

                // Touch move
                chatPanel.addEventListener('touchmove', function(e) {
                    if (!isSwiping || !chatPanel.classList.contains('fullscreen')) return;

                    const currentY = e.touches[0].clientY;
                    const currentX = e.touches[0].clientX;
                    const deltaY = currentY - startY;
                    const deltaX = Math.abs(currentX - startX);

                    // Only handle vertical swipes
                    if (deltaX < 50 && deltaY > 50) {
                        swipeIndicator.classList.add('show');
                        e.preventDefault(); // Prevent scrolling
                    } else {
                        swipeIndicator.classList.remove('show');
                    }
                }, { passive: false });

                // Touch end
                chatPanel.addEventListener('touchend', function(e) {
                    if (!isSwiping) return;

                    const endY = e.changedTouches[0].clientY;
                    const deltaY = endY - startY;

                    swipeIndicator.classList.remove('show');

                    // If swiped down more than 100px, close fullscreen
                    if (deltaY > 100 && chatPanel.classList.contains('fullscreen')) {
                        setPanelMode('docked');
                        // Add haptic feedback
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }

                    isSwiping = false;
                });

                // Add haptic feedback to buttons
                const buttons = document.querySelectorAll('button');
                buttons.forEach(button => {
                    button.addEventListener('touchstart', function() {
                        this.classList.add('haptic-feedback');
                        if (navigator.vibrate) {
                            navigator.vibrate(10);
                        }
                    });

                    button.addEventListener('touchend', function() {
                        this.classList.remove('haptic-feedback');
                    });
                });

                // Improve scrolling performance on mobile
                const chatLog = document.getElementById('chat-log');
                let scrollTimeout;

                chatLog.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(function() {
                        // Hide virtual keyboard when scrolling
                        document.activeElement.blur();
                    }, 150);
                }, { passive: true });

                // Handle orientation changes
                window.addEventListener('orientationchange', function() {
                    setTimeout(function() {
                        chatLog.scrollTop = chatLog.scrollHeight;
                        // Recalculate panel position
                        if (chatPanel.classList.contains('docked')) {
                            chatPanel.style.bottom = '20px';
                        }
                    }, 500);
                });

                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(event) {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                // Add pull-to-refresh for chat messages
                let pullStartY = 0;
                let isPulling = false;

                chatLog.addEventListener('touchstart', function(e) {
                    if (chatLog.scrollTop === 0) {
                        pullStartY = e.touches[0].clientY;
                        isPulling = true;
                    }
                }, { passive: true });

                chatLog.addEventListener('touchmove', function(e) {
                    if (!isPulling) return;

                    const pullDistance = e.touches[0].clientY - pullStartY;
                    if (pullDistance > 50) {
                        // Show refresh indicator
                        chatLog.style.transform = `translateY(${Math.min(pullDistance - 50, 60)}px)`;
                        e.preventDefault();
                    }
                }, { passive: false });

                chatLog.addEventListener('touchend', function(e) {
                    if (!isPulling) return;

                    const pullDistance = e.changedTouches[0].clientY - pullStartY;
                    chatLog.style.transform = '';

                    if (pullDistance > 100) {
                        // Trigger refresh
                        console.log('Pull to refresh triggered');
                        // Could reload messages or show new messages
                    }

                    isPulling = false;
                });
            }
        }

        // Initialize widget active state
        updateWidgetActiveState();
        initializeMobileInteractions();

        // Cleanup function for when widget disconnects
        function cleanupWidgetResources() {
            if (widgetVisibilityObserver) {
                widgetVisibilityObserver.disconnect();
                widgetVisibilityObserver = null;
            }
            if (readReceiptTimeout) {
                clearTimeout(readReceiptTimeout);
                readReceiptTimeout = null;
            }
        }

        // Global function to update notification count from widget
        window.updateNotificationFromWidget = function() {
            console.log('Widget: Updating notification count from widget');
            if (window.NotificationManager && window.NotificationManager.forceRefresh) {
                window.NotificationManager.forceRefresh();
            }
        };

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupWidgetResources);

        let lastRoomId = null;
        async function connectSocketWithHistory(roomId) {
            if (roomId === lastRoomId) return; // No recargar si no cambió la sala

            // Validate room ID
            if (!roomId || roomId.trim() === '') {
                console.error('Cannot connect: Invalid room ID');
                return;
            }

            lastRoomId = roomId;
            await loadHistory(roomId);
            // Reset unread count when loading history
            setTimeout(() => resetUnreadCount(roomId), 500);

            if (chatSocket) {
                intentionalClose = true;
                chatSocket.close();
                intentionalClose = false;
            }
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const wsPath = `${wsScheme}://${window.location.host}/ws/chat/${roomId}/`;
            console.log('Panel connecting to WebSocket:', wsPath);
            chatSocket = new WebSocket(wsPath);
            chatSocket.onmessage = function(e) {
                const data = JSON.parse(e.data);
                if (data.type === 'typing_start') {
                    if (data.user_id != currentUserId) {
                        showTypingIndicator(data.user_id, data.display_name);
                    }
                    return;
                }
                if (data.type === 'typing_stop') {
                    hideTypingIndicator();
                    return;
                }
                if (data.type === 'history_cleared') {
                    // Clear the chat history for all users in the room
                    handleHistoryCleared();
                    return;
                }
                if (data.message) {
                    const isCurrentUser = data.user_id == currentUserId;

                    // Track unread messages only if widget is not active
                    if (!isCurrentUser && !isWidgetActive) {
                        unreadMessageCount++;
                        console.log('Panel: Unread message count:', unreadMessageCount);
                    } else if (!isCurrentUser && isWidgetActive) {
                        // Widget is active, mark this message as read after a short delay
                        console.log('Panel: Widget active, will mark message as read');
                        clearTimeout(readReceiptTimeout);
                        readReceiptTimeout = setTimeout(() => {
                            if (lastRoomId && isWidgetActive) {
                                resetUnreadCount(lastRoomId);
                            }
                        }, 500); // Reduced to 0.5 seconds for faster confirmation
                    }

                    const msgHtml = `<div class="d-flex mb-2 justify-content-${isCurrentUser ? 'end' : 'start'}">
                        <div class="message-bubble px-3 py-2 ${isCurrentUser ? 'outgoing text-white text-end' : 'incoming text-dark text-start'}" style="max-width: 75%; border-radius: 1.2em; background:${isCurrentUser ? '#007bff' : '#f8f9fa'};">
                            <div class="small fw-bold mb-1">${data.display_name || 'Usuario'}</div>
                            <div class="message-content">${data.message}</div>
                            <div class="message-time small mt-1 text-muted">${data.timestamp ? data.timestamp.substring(11,19) : ''}</div>
                        </div>
                    </div>`;
                    chatLog.insertAdjacentHTML('beforeend', msgHtml);
                    chatLog.scrollTop = chatLog.scrollHeight;
                }
            };
            chatSocket.onclose = function(e) {
                // Solo reconectar si la sala sigue siendo la misma
                if (!intentionalClose && roomId === lastRoomId) {
                    reconnectTimeout = setTimeout(() => connectSocketWithHistory(roomId), 2000);
                }
            };

            chatSocket.onopen = function() {
                console.log('Panel: WebSocket connected, setting up visibility observer');
                // Setup visibility observer when WebSocket connects
                setTimeout(updateWidgetActiveState, 100);
            };
        }
        // Conectar al inicio después de cargar las salas
        setTimeout(() => {
            if (roomSelector.value && roomSelector.value !== '') {
                console.log('Panel: Connecting to initial room:', roomSelector.value);
                connectSocketWithHistory(roomSelector.value);
            } else {
                console.log('Panel: No room selected, waiting for user selection');
            }
        }, 1000); // Give time for room loading to complete

        roomSelector.addEventListener('change', function() {
            const newRoomId = roomSelector.value;
            if (newRoomId) {
                // Save to localStorage for persistence
                localStorage.setItem('chatPanelLastRoom', newRoomId);
                console.log('Panel: Saved room to localStorage:', newRoomId);

                connectSocketWithHistory(newRoomId);
                // Reset unread count when switching rooms
                setTimeout(() => resetUnreadCount(newRoomId), 1000);
            }
        });
        chatSubmit.addEventListener('click', function() {
            const message = chatInput.value.trim();
            if (message && chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({ 'message': message }));
                chatInput.value = '';
            }
        });
        chatInput.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                chatSubmit.click();
            }
        });

        chatInput.addEventListener('input', function(e) {
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                if (!isTyping) {
                    isTyping = true;
                    chatSocket.send(JSON.stringify({
                        'type': 'typing_start'
                    }));
                }
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(function() {
                    isTyping = false;
                    chatSocket.send(JSON.stringify({
                        'type': 'typing_stop'
                    }));
                }, 1000);
            }
        });
    });
</script>
